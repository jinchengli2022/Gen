# 关节限位问题解决方案

## 问题描述

在 PouringWater 任务的 Move 段执行过程中，UR5e 的 q5（末端旋转关节，范围 ±2π）从 -3.66 连续累积到 -6.28，撞到下限 -6.2832。

**根本原因**：OSC 控制器追踪笛卡尔空间的位姿增量时，只管"当前帧误差最小化"，没有全局关节角管理意识。q5 沿一个方向持续累积旋转，最终超出关节范围。

**关键洞察**：机械臂的任意末端姿态都是可达的。q5 差 2π 的整数倍对应同一个末端姿态。问题不在于"姿态不可达"，而在于控制器选择了一条导致 q5 累积触限的路径。

---

## 方案一：笛卡尔空间旋转 Unwinding（OSC 补丁）

### 思路

在生成好完整的 (N, 4, 4) 目标位姿序列后，不改变任何末端姿态的物理含义，但调整旋转的"表达方式"，试图引导 OSC 控制器选择不触限的关节路径。

### 具体做法

- 在 Move 段开始前，**插入一段"原地预旋转"过渡**，让 q5 先转到一个安全的中间位置，再执行正式 Move 段
- 或者，在轨迹生成完成后，检查连续帧的旋转增量是否一直沿同一方向累积，若是则在中间某处插入一个等效的 2π 反向旋转

### 优点

- 改动最小，不改控制器，不改控制架构
- 完全在现有 `trajectory_generator.py` 中实现

### 缺点

- **无法真正控制关节角**：笛卡尔空间的旋转矩阵/四元数天然取"最短弧"（Slerp 双覆盖性质），我们在笛卡尔空间能施加的影响有限
- OSC 是力矩级控制器，它的零空间行为（关节角漂移方向）不完全由笛卡尔输入决定
- 预旋转过渡会增加步数，且不保证 OSC 一定会把 q5 转到我们期望的位置

### 适用场景

- 作为应急补丁，快速缓解问题
- 限位触发不频繁的场景

---

## 方案二：IK 预计算 + JOINT_POSITION 控制（全局最优解）

### 思路

放弃 OSC 的笛卡尔增量控制，改为：先用 IK 将整条笛卡尔轨迹转换为关节空间轨迹，在关节空间做全局 unwinding，然后用 JOINT_POSITION 控制器直接追踪关节角目标。

### 具体做法

1. **笛卡尔轨迹生成**（现有逻辑不变）
2. **IK 逐帧求解**：对每个目标位姿 (4x4)，用 MuJoCo 的微分 IK（`mj_jacSite` + 伪逆）求一组关节角 (6D)
3. **关节空间 Unwinding**：遍历关节角序列，对每个旋转关节（特别是 q5），如果相邻帧跳变 > π，就加/减 2π 使其连续。然后检查整条轨迹是否在 [-2π+margin, 2π-margin] 范围内，若不在则整体偏移 2π
4. **切换到 JOINT_POSITION 控制器**：`WaypointPolicy` 直接输出目标关节角，由 JOINT_POSITION 控制器的 PD 控制追踪

### 代码改动

| 文件 | 改动 |
|------|------|
| `trajectory_generator.py` | 新增 `_cartesian_to_joint_trajectory()` 方法：调用 MuJoCo IK，逐帧求解 + unwinding |
| `gen.py` WaypointPolicy | 新增 JOINT_POSITION 分支：action 直接输出目标关节角（不再计算笛卡尔增量） |
| `config.py` / JSON | `controller_type` 设为 `"JOINT_POSITION"` |
| `robosuite_env.py` | 已支持（上一轮改动已适配） |

### IK 求解伪代码

```python
def cartesian_to_joint_trajectory(self, cartesian_poses, sim, joint_indices, site_name):
    """
    将 (N, 4, 4) 笛卡尔轨迹转换为 (N, 6) 关节角轨迹。
    """
    n = len(cartesian_poses)
    joint_traj = np.zeros((n, len(joint_indices)))
    
    for i in range(n):
        target_pos = cartesian_poses[i][:3, 3]
        target_rot = cartesian_poses[i][:3, :3]
        
        # 微分 IK 迭代求解
        for _ in range(max_iterations):
            current_pos = sim.data.site(site_name).xpos
            current_rot = sim.data.site(site_name).xmat.reshape(3,3)
            
            pos_error = target_pos - current_pos
            rot_error = orientation_error(target_rot, current_rot)
            
            if np.linalg.norm(pos_error) < tol and np.linalg.norm(rot_error) < tol:
                break
            
            J = get_jacobian(sim, site_name, joint_indices)
            dq = np.linalg.pinv(J) @ np.concatenate([pos_error, rot_error])
            sim.data.qpos[joint_indices] += dq * step_size
            mujoco.mj_forward(sim.model, sim.data)
        
        joint_traj[i] = sim.data.qpos[joint_indices].copy()
    
    # 全局 unwinding
    joint_traj = self._unwinding(joint_traj, joint_limits)
    return joint_traj

def _unwinding(self, joint_traj, joint_limits):
    """
    对关节角序列做连续化 + 限位避让。
    对旋转关节（range >= 2π 的），相邻帧差 > π 时加/减 2π。
    然后整体偏移使轨迹在安全范围内。
    """
    n, dof = joint_traj.shape
    for j in range(dof):
        lo, hi = joint_limits[j]
        if (hi - lo) < 2 * np.pi - 0.01:
            continue  # 非全周旋转关节，跳过
        
        # 1. 连续化：消除 2π 跳变
        for i in range(1, n):
            diff = joint_traj[i, j] - joint_traj[i-1, j]
            while diff > np.pi:
                joint_traj[i, j] -= 2 * np.pi
                diff -= 2 * np.pi
            while diff < -np.pi:
                joint_traj[i, j] += 2 * np.pi
                diff += 2 * np.pi
        
        # 2. 整体偏移：使轨迹在 [lo+margin, hi-margin] 内
        margin = 0.1  # rad, ~5.7°
        traj_min = np.min(joint_traj[:, j])
        traj_max = np.max(joint_traj[:, j])
        
        if traj_min < lo + margin:
            shift = np.ceil((lo + margin - traj_min) / (2*np.pi)) * 2*np.pi
            joint_traj[:, j] += shift
        elif traj_max > hi - margin:
            shift = np.ceil((traj_max - hi + margin) / (2*np.pi)) * 2*np.pi
            joint_traj[:, j] -= shift
    
    return joint_traj
```

### 优点

- **根治问题**：在关节空间直接管理每个关节角，unwinding 保证永不触限
- **全局最优**：可以站在整条轨迹的高度做优化，而非逐帧贪心
- **干净**：笛卡尔轨迹生成和关节空间追踪完全解耦

### 缺点

- 改动较大，需要实现 IK 求解器 + unwinding + JOINT_POSITION 控制适配
- IK 求解可能失败（奇异位形、数值不收敛），需要鲁棒性处理
- JOINT_POSITION 控制器的 PD 参数需要调试（追踪精度、阻尼等）
- 生成的 action 格式变了（从笛卡尔增量变成关节角目标），**下游 VLA 训练数据的 action 语义会改变**

### 适用场景

- 长期解决方案，彻底消除所有关节限位问题
- 对轨迹精度要求高的场景

---

## 方案三：事后检测 + 跳过不可达场景（兜底方案）

### 思路

在生成轨迹并执行后（或执行前用 IK 预检），检测是否会触发关节限位。若会触限，直接跳过该 episode，换一个新的随机场景配置重新尝试。

### 具体做法

- **执行后检测**（最简单）：在 `collect_episode()` 中，若检测到任何关节 margin < 阈值，标记该 episode 为失败
- **执行前检测**（更高效）：生成笛卡尔轨迹后，用 IK 预跑一遍（不执行，只算关节角），检查是否有超限风险。超限则直接跳过

### 可选增强：配合限制物体旋转范围

在 PouringWater 环境的 placement sampler 中，限制物体的 Z 轴随机旋转范围（如 ±30°），减少极端场景出现的概率。

### 优点

- 实现极简，几行代码
- 不改动轨迹生成和控制逻辑

### 缺点

- 浪费采样：触限的场景被丢弃
- 如果触限概率高，数据生成效率很低
- 没有从根本上解决问题

### 适用场景

- 作为方案一或方案二的补充兜底
- 触限概率较低（<10%）的场景

---

## 方案对比

| | 方案一：笛卡尔 Unwinding | 方案二：IK + JOINT_POSITION | 方案三：检测 + 跳过 |
|---|---|---|---|
| **改动量** | 小 | 大 | 极小 |
| **解决程度** | 缓解（不保证） | 根治 | 回避 |
| **对下游 VLA 训练的影响** | 无（action 格式不变） | **大**（action 从笛卡尔变关节角） | 无 |
| **数据生成效率** | 高 | 高 | 取决于触限概率 |
| **实现难度** | 低 | 高（IK + 调参） | 极低 |
| **鲁棒性** | 中 | 高 | 高（跳过就是安全的） |

## 建议

**如果下游 VLA 训练使用笛卡尔 action（当前架构）**：方案三（检测+跳过）为主，方案一辅助，最务实。

**如果愿意切换到关节角 action**：方案二是终极解，但需要评估对 VLA 训练的影响。

**短期推荐组合**：方案三 + 限制物体旋转范围，快速解除当前阻塞，后续再考虑方案二。
